eat - sleep - think

enquanto um filosofo come, outro dorme, outro pensa, outro come
	nao podem comer dois ao mesmo lado, por causa dos garfos

se for so 1 filosofo, morre porque nao tem 2 garfos

se forem 2 filosofos vivem desde que um coma a seguir ao outro e time to die = time to sleep + time to eat

se forem EVEN filosofos 
	1		2	  3 	4
	eat - sleep - eat - sleep

se forem ODD filosofos
	1		2		3	   4	  5
	eat - think - sleep - eat - think

1 filosofo e um garfo / thread

pthread_t th[av[2]];

typdef struct s_philo{
	int	i;
	int	state;
	s_philo *next;
} t_philo;

      
routine()
{
	pega garfos
	come (conta tempo)
	larga garfos
	dorme (conta tempo)
	pensa (conta tempo)
}

MAIN COM i (sem curr)

int	main(int ac, char **av)
{
	t_philo		*curr;
	int			i;
	int			*a;

	if (check_args(ac, av))
	{
		fill_philos(new_atoi(av[1]));
		curr = table()->first_phil;
		i = 0;
		while (curr)
		{
			// a = malloc(sizeof(int));
			// *a = curr->i;
			if (pthread_create(&curr->thread, 0, &routine, curr) != 0)
				printf("Failed to create thread");
			// i++;
			curr = curr->next;
		}
		curr = table()->first_phil;
		// i = 0;
		while (curr)
		{
			if (pthread_join(curr->thread, 0) != 0)
				printf("Failed to join thread");
			// i++;
			curr = curr->next;
		}
		free_philos();
	}
	return (0);
}
		1					2			3			4					5
number_of_philosophers time_to_die time_to_eat time_to_sleep [number_of_times_each_philosopher_must_eat]

falta protecao para 1 philo