swap ok
rotate ok
rev_rotate ok
push ok

falta juntar o list clear final para poupar uma linha na main (push_swap.c)

retirar os print_stacks

6 4 2 1 3 5
pb pb pb
sort
1 3 5 // 6 4 2
pa
6 1 3 5 // 4 2
rot
5 6 1 3 // 4 2
pa
4 5 6 1 3 // 2
rotate
3 4 5 6 1 // 2
pa
2 3 4 5 6 1
rotate






2 7 3 6 5 8
pb pb pb
6 5 8 // 3 7 2 
sort (sa)
5 6 8 // 3 7 2 (if b1 < a1 fazer pa)
pa
3 5 6 8 // 7 2 (repor ao inicio)
rev_rotate
5 6 8 3 // 7 2 
rotate
6 8 3 5 // 7 2 (se nao entra fazer rotate)
rotate
8 3 5 6 // 7 2 (se entrar, fazer pa)
pa
7 8 3 5 6 // 2 (se fez rotate, desfazer e voltar ao inicio)
rev_rotate
8 3 5 6 7 // 2 (se fez rotate, desfazer e voltar ao inicio)
rev_rotate
3 5 6 7 8 // 2
pa
2 3 5 6 7 8


7 2 3 5 6 8

6 5 8 // 3 2 7

5 6 8 // 3 2 7

3 5 6 8 // 2 7

2 3 5 6 8 // 7

8 2 3 5 6 // 7

7 8 2 3 5 6 


2 7 3 6 5 8

6 5 8 // 3 7 2

5 6 8 // 3 7 2

3 5 6 8 // 7 2

8 3 5 6 // 7 2

7 8 3 5 6 // 2

8 3 5 6 7 // 2

3 5 6 7 8 // 2

2 3 5 6 7 8


1 2 3 6 5 8

6 5 8 // 3 2 1

5 6 8 // 3 2 1

3 5 6 8 // 2 1

2 3 5 6 8 // 1

1 2 3 5 6 8


5 8 3 9 1 7 6 2 4 0

2 4 0 // 6 7 1 9 3 8 5 pb a tudo menos ultimos 3

0 2 4 // 6 7 1 9 3 8 5 sort a

2 4 0 // 6 7 1 9 3 8 5 pa so se (b1 < a1)*

4 0 2 // 6 7 1 9 3 8 5

0 2 4 // 6 7 1 9 3 8 5

6 0 2 4 // 7 1 9 3 8 5 *ou quando da a volta ao a

0 2 4 6 // 7 1 9 3 8 5 deixar organizado

2 4 6 0 // 7 1 9 3 8 5 pa so se (b1 < a1)*

4 6 0 2 // 7 1 9 3 8 5

6 0 2 4 // 7 1 9 3 8 5

0 2 4 6 // 7 1 9 3 8 5

7 0 2 4 6 // 1 9 3 8 5 *ou quando da a volta ao a

0 2 4 6 7 // 1 9 3 8 5 deixar organizado

2 4 6 7 0 // 1 9 3 8 5 pa so se (b1 < a1)

1 2 4 6 7 0 // 9 3 8 5

0 1 2 4 6 7 // 9 3 8 5 deixar organizado

...