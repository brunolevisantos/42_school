swap ok
rotate ok
rev_rotate ok
push ok

completei a funcao below_avg_to_b para fazer push assim que der uma volta completa
alterei void rotate para int rotate, para saber quantas vezes rodou

falta juntar o list clear final para poupar uma linha na main (push_swap.c)

fazer funcao que calcule o melhor elemento para passar para o a, sendo que e o mais perto do best neighbour
retirar os print_stacks

6 4 2 1 3 5
pb pb pb
sort
1 3 5 // 6 4 2
pa
6 1 3 5 // 4 2
rot
5 6 1 3 // 4 2
pa
4 5 6 1 3 // 2
rotate
3 4 5 6 1 // 2
pa
2 3 4 5 6 1
rotate






2 7 3 6 5 8
pb pb pb
6 5 8 // 3 7 2 
sort (sa)
5 6 8 // 3 7 2 (if b1 < a1 fazer pa)
pa
3 5 6 8 // 7 2 (repor ao inicio)
rev_rotate
5 6 8 3 // 7 2 
rotate
6 8 3 5 // 7 2 (se nao entra fazer rotate)
rotate
8 3 5 6 // 7 2 (se entrar, fazer pa)
pa
7 8 3 5 6 // 2 (se fez rotate, desfazer e voltar ao inicio)
rev_rotate
8 3 5 6 7 // 2 (se fez rotate, desfazer e voltar ao inicio)
rev_rotate
3 5 6 7 8 // 2
pa
2 3 5 6 7 8


7 2 3 5 6 8

6 5 8 // 3 2 7

5 6 8 // 3 2 7

3 5 6 8 // 2 7

2 3 5 6 8 // 7

8 2 3 5 6 // 7

7 8 2 3 5 6 


2 7 3 6 5 8

6 5 8 // 3 7 2

5 6 8 // 3 7 2

3 5 6 8 // 7 2

8 3 5 6 // 7 2

7 8 3 5 6 // 2

8 3 5 6 7 // 2

3 5 6 7 8 // 2

2 3 5 6 7 8


1 2 3 6 5 8

6 5 8 // 3 2 1

5 6 8 // 3 2 1

3 5 6 8 // 2 1

2 3 5 6 8 // 1

1 2 3 5 6 8


5 8 3 9 1 7 6 2 4 0

2 4 0 // 6 7 1 9 3 8 5 pb a tudo menos ultimos 3

0 2 4 // 6 7 1 9 3 8 5 sort a

2 4 0 // 6 7 1 9 3 8 5 pa so se (b1 < a1)*

4 0 2 // 6 7 1 9 3 8 5

0 2 4 // 6 7 1 9 3 8 5

6 0 2 4 // 7 1 9 3 8 5 *ou quando da a volta ao a

0 2 4 6 // 7 1 9 3 8 5 deixar organizado

2 4 6 0 // 7 1 9 3 8 5 pa so se (b1 < a1)*

4 6 0 2 // 7 1 9 3 8 5

6 0 2 4 // 7 1 9 3 8 5

0 2 4 6 // 7 1 9 3 8 5

7 0 2 4 6 // 1 9 3 8 5 *ou quando da a volta ao a

0 2 4 6 7 // 1 9 3 8 5 deixar organizado

2 4 6 7 0 // 1 9 3 8 5 pa so se (b1 < a1)

1 2 4 6 7 0 // 9 3 8 5

0 1 2 4 6 7 // 9 3 8 5 deixar organizado

...

avg = 4 lap iiiiiii

6 5 8 1 2 3 7 min = 6
rot
5 8 1 2 3 7 6
rot
8 1 2 3 7 6 5
rot
1 2 3 7 6 5 8
push
2 3 7 6 5 8 // 1
push
3 7 6 5 8 // 2 1
push
7 6 5 8 // 3 2 1
rot
6 5 8 7 // 3 2 1
push
5 8 7 // 6 3 2 1
rev_rotate
7 5 8 // 6 3 2 1
swap
5 7 8 // 6 3 2 1
rotate
7 8 5 // 6 3 2 1
push
6 7 8 5 // 3 2 1
rev_rotate
5 6 7 8 // 3 2 1        5 6 7 8 // 1 2 3
push                    push
3 5 6 7 8 // 2 1        1 5 6 7 8 // 2 3
push                    rotate
2 3 5 6 7 8 // 1        5 6 7 8 1 // 2 3
push                    push
1 2 3 5 6 7 8           2 5 6 7 8 1 // 3
                        rev_rotate
                        1 2 5 6 7 8 // 3
                        rot
                        2 5 6 7 8 1 // 3
                        rot
                        5 6 7 8 1 2 // 3
                        push
                        3 5 6 7 8 1 2
                        rev_rotate
                        2 3 5 6 7 8 1
                        rev_rotate
                        1 2 3 5 6 7 8



3 5 11 10 15 // 20 7 6 2